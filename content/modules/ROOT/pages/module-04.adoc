== Managing Pods with Systemd and Quadlet

Quadlet is a systemd generator, that will take your pod definition, and register it as a service in systemd. We have provided a quadlet pod defintion for you.

.Command
[source,bash,subs="+macros,+attributes",role=execute]
----
cat my-networked-pod.kube
----

.Output
[source,text]
----
[Install]
WantedBy=default.target

[Unit]
# You can use standard unit options to control the start-up order of your pod.
# Such as:
#After=
#Requires=

[Kube]
# In this section you can define several things
# here we are simply calling the kube yaml we generated with podman
Yaml=/etc/containers/systemd/my-networked-pod.yaml

#We also need to define the ports that our pod maps int, just as we do a the pod level
PublishPort=8080:80
----

You can see the similarities in the above output, and a standard systemd unit file. You can add in start up options, ordering, and other systemd configuration to tune when and how this pod starts up.

As you can see, the path to the pod yaml is `+/etc/containers/systemd/my-networked-pod.yaml+`. You can place your yaml definition elsewhere if you would like, but this is also where the `+.kube+` quadlet defintion needs to be placed. Keeping them toghether makes it clean for this lab.

Let's copy the files into place.


.Command
[source,bash,subs="+macros,+attributes",role=execute]
----
cp ~/my-networked-pod.yaml /etc/containers/systemd
----

This command has no expected output.

And then

.Command
[source,bash,subs="+macros,+attributes",role=execute]
----
cp ~/my-networked-pod.kube /etc/containers/systemd
----

This command has no expected output.

Now, if we reload systemd, quadlet will generate a service unit for our pod. You can also test the generation using quadlet in a dry-run.

.Command
[source,bash,subs="+macros,+attributes",role=execute]
----
/usr/libexec/podman/quadlet -dryrun
----

.Output
[source,text]
----
quadlet-generator[4025]: Loading source unit file /etc/containers/systemd/my-networked-pod.kube
---my-networked-pod.service---
[Install]
WantedBy=default.target

[Unit]
SourcePath=/etc/containers/systemd/my-networked-pod.kube
RequiresMountsFor=%t/containers

# You can use standard unit options to control the start-up order of your pod.
# Such as:
#After=
#Requires=

[X-Kube]
# In this section you can define several things
# here we are simply calling the kube yaml we generated with podman
Yaml=/etc/containers/systemd/my-networked-pod.yaml

#We also need to define the ports that our pod maps int, just as we do a the pod level
PublishPort=8080:90

[Service]
KillMode=mixed
Environment=PODMAN_SYSTEMD_UNIT=%n
Type=notify
NotifyAccess=all
SyslogIdentifier=%N
ExecStart=/usr/bin/podman kube play --replace --service-container=true --publish 8080:90 /etc/containers/systemd/my-networked-pod.yaml
ExecStopPost=/usr/bin/podman kube down /etc/containers/systemd/my-networked-pod.yaml
----

Using this dry run, you can see what qadlet will do when you reload systemd.

Notice the `+ExecStart+` command in the service. You can see the `+--replace+` flag, which means each time you start this service, it will re-read the kube definition, and replace your pod. This means that changes to the pod's definition and updates to the container images that the definition calls, will be pulled in automatically every time the pod is started using systemd.

This looks fine, so let's get this definiteion in place.

.Command
[source,bash,subs="+macros,+attributes",role=execute]
----
systemctl daemon-reload
----

This command has no expected output.

Now we can start the service up, but first, let's check podman, and make sure we dont already have our pod running.

.Command
[source,bash,subs="+macros,+attributes",role=execute]
----
podman pod ps
----

.Output
[source,text]
----
POD ID      NAME        STATUS      CREATED     INFRA ID    # OF CONTAINERS
----

Looks good, Let's start our pod up.

.Command
[source,bash,subs="+macros,+attributes",role=execute]
----
systemctl start my-networked-pod.service
----

This command has no expected output.

This should go and download any container images that are neccessary, and then start up our pod.

.Command
[source,bash,subs="+macros,+attributes",role=execute]
----
systemctl status my-networked-pod.service
----

.Output
[source,text]
----
● my-networked-pod.service
     Loaded: loaded (/etc/containers/systemd/my-networked-pod.kube; generated)
     Active: active (running) since Fri 2025-03-07 20:09:58 UTC; 37s ago
   Main PID: 44351 (conmon)
      Tasks: 3 (limit: 22484)
     Memory: 2.3M
        CPU: 668ms
     CGroup: /system.slice/my-networked-pod.service
             ├─4857 /usr/bin/conmon --api-version 1 -c 86b713eda7f56e49902b217268f7619bd9e455cebb2ef7d3b5820fd92ce58e41 -u 86b713eda7f56e>
             ├─4928 /usr/bin/conmon --api-version 1 -c cd046b7b107d64d13e47cc14449e69739aab23f8c526bbd54c394861ec253f72 -u cd046b7b107d64>
             └─4934 /usr/bin/conmon --api-version 1 -c fff1424f8329ee251d60be28f1eae7d2b79c367a1f82b94cda6309febebe05bf -u fff1424f8329ee

----

NOTE: The above output may show red warnings regarding the server's FQDN. Ignore these for this lab. Press *'+q+'* to exit the service status

.Command
[source,bash,subs="+macros,+attributes",role=execute]
----
podman pod ps
----

.Output
[source,text]
----
POD ID        NAME              STATUS      CREATED             INFRA ID      # OF CONTAINERS
34c2405415bd  my-networked-pod  Running     About a minute ago  cd046b7b107d  2
----

Now the `+my-networked-pod+` pod can be controlled via systemctl, and will even start up on system boot-up.
